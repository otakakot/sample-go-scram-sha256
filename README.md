# sample-go-scram-sha256

## SCRAM-SHA256 認証実装例

このプロジェクトは、RFC 5802 に基づいた SCRAM-SHA256 認証プロセスの簡易実装例です。Go 言語を用いて、サーバー側とクライアント側の両方の実装を提供しています。認証ハンドシェイクの各ステップを通じて、ユーザー認証がどのように行われるかを学ぶことができます。

---

## 構成

- **main.go**  
  - サーバーのエントリーポイント。  
  - `/scram` エンドポイントを設定し、クライアントからの認証リクエスト（"client-first" および "client-final" メッセージ）に対して処理を行います。  
  - 詳細な実装やアルゴリズムは `cmd/main.go` に記述されています。

- **cmd/main.go**  
  - クライアント側の実装例です。  
  - サーバー (main.go で起動中) の `/scram` エンドポイントに対して、SCRAM 認証プロセスの "client-first" と "client-final" のメッセージを送信し、認証ハンドシェイクを実施します。  
  - 各種操作（PBKDF2、HMAC-SHA256、XOR による client proof の生成）を用いています。

- **openapi.yaml**  
  - このプロジェクトの SCRAM-SHA256 認証 API の OpenAPI 3.0.3 仕様書です。  
  - `/scram` エンドポイントのリクエスト/レスポンスの形式が定義されています。

- **go.mod / go.sum**  
  - Go モジュールの依存管理ファイルです。

---

## 特徴

- **SCRAM-SHA256 認証**  
  - クライアントとサーバー間で安全に認証を行うためのプロトコル。  
  - サーバー側は、クライアントの "client-first" メッセージを受け取り、サーバー側の nonce、salt、反復回数を用いて認証情報を生成します。  
  - クライアント側は、受信した情報を基に client proof を計算し、"client-final" メッセージとして送信します。  
  - サーバーはこれを検証し、認証成功時にはサーバー署名（server signature）を返します。

- **Go による実装**  
  - 標準ライブラリ（net/http など）と外部ライブラリ（golang.org/x/crypto/pbkdf2）を使用。  
  - 各処理の意図やアルゴリズム（PBKDF2、HMAC、XOR）の実装については、コード内に詳細な日本語コメントを記載しています。

- **参考資料**  
  - [RFC 5802](https://tools.ietf.org/html/rfc5802)  
  - [Go 公式ドキュメント](https://golang.org/doc/)

---

## セットアップおよび実行方法

1. **依存関係のインストール**  
   プロジェクトルートで以下のコマンドを実行して依存関係を取得してください。
   ```
   go mod tidy
   ```

2. **サーバーの起動**  
   以下のコマンドでサーバーを起動します。  
   ```
   go run main.go
   ```
   サーバーはポート 8080 で起動し、`/scram` エンドポイントを提供します。

3. **クライアントの実行**  
   別のターミナルで以下のコマンドを実行します。
   ```
   go run cmd/main.go
   ```
   クライアントは、サーバーに対して SCRAM 認証のハンドシェイクを行い、認証結果を表示します。

---

## 注意事項

- この実装は、学習やデモンストレーションを目的としています。  
  実運用にあたっては、ユーザー管理、セッション管理、セキュリティ対策、エラーハンドリングの強化が必要となります。

- パスワードや秘密情報は安全に管理してください。

---

## 参考資料

- **RFC 5802**: [SCRAM: Salted Challenge Response Authentication Mechanism](https://tools.ietf.org/html/rfc5802)  
- **Go 公式ドキュメント**: [https://golang.org/doc/](https://golang.org/doc/)  
- **Go net/http パッケージ**: [https://golang.org/pkg/net/http/](https://golang.org/pkg/net/http/)

## Gemini に聞いたメモ

SCRAM (Salted Challenge Response Authentication Mechanism) についてですね。RFC 5802 に詳しく記載されていますので、そちらを基に、分かりやすくご説明します。図も用いて解説しますので、ご安心ください。

**SCRAM とは？**

SCRAM は、クライアントとサーバー間で安全に認証を行うための仕組みの一つです。パスワードなどの認証情報をネットワーク上で直接やり取りすることなく、安全な認証を実現することを目的としています。特に、従来のパスワード認証方式に比べて、セキュリティを大幅に向上させるように設計されています。

**RFC 5802 について**

ご提示の URL ( [https://datatracker.ietf.org/doc/html/rfc5802](https://datatracker.ietf.org/doc/html/rfc5802) ) は、まさに SCRAM を定義している RFC 5802 (Salted Challenge Response Authentication Mechanism) のドキュメントです。この RFC は、インターネット技術標準化委員会 (IETF) によって標準化されたもので、SCRAM の詳細な仕様が記載されています。

**SCRAM の認証プロセス**

SCRAM の認証プロセスは、主に以下のステップで構成されています。認証の際には、クライアントとサーバーが複数回メッセージを交換し、互いに認証を行います。

大きく分けて、「クライアントファースト」と「サーバーファースト」の 2 つのバリエーションがありますが、基本となる考え方は同じです。ここでは、一般的な「クライアントファースト」の流れを中心に説明します。

1. **クライアント Hello (Client Hello)**:
   クライアントは、サーバーに対して認証を開始する旨を伝えるメッセージを送信します。このメッセージには、クライアントが認証に使用するユーザー名が含まれます。

2. **サーバー First Message (Server First Message)**:
   サーバーは、クライアントからの Hello メッセージを受け取ると、サーバーの認証に必要な情報（ソルト値、サーバーのイテレーション回数、使用するハッシュ関数など）を含むメッセージをクライアントに送信します。ソルト値は、セキュリティを高めるためにランダムに生成される値です。イテレーション回数は、ハッシュ関数を繰り返し適用する回数を示し、計算コストを上げて攻撃を困難にします。

3. **クライアント Final Message (Client Final Message)**:
   クライアントは、サーバーから受け取った情報と、ユーザーのパスワード、クライアント自身が生成したランダムな値（クライアントnonce）などを用いて、認証情報を計算します。この認証情報には、パスワードそのものは含まれず、ハッシュ関数とソルト値を用いた計算結果が含まれます。計算された認証情報をサーバーに送信します。

4. **サーバー Final Message (Server Final Message)**:
   サーバーは、クライアントから受け取った認証情報と、サーバー自身が保持しているユーザーのパスワード情報、サーバーnonceなどを用いて、同様の認証情報を計算し、クライアントから受け取った情報と一致するかどうかを検証します。検証に成功した場合、サーバーは認証成功のメッセージをクライアントに送信します。また、サーバーも自身の認証情報をクライアントに送信し、クライアントがサーバーを認証できるようにします。

**図解: SCRAM 認証プロセス (クライアントファースト)**

以下に、クライアントファーストの SCRAM 認証プロセスの概略図を示します。

```
クライアント                                   サーバー
----------------------------------------------------
1. クライアント Hello (ユーザー名)  ----->
                                         <-----  2. サーバー First Message (ソルト, イテレーション回数, ...)
3. クライアント Final Message (クライアント証明, ...) ----->
                                         <-----  4. サーバー Final Message (サーバー証明, 認証結果)
----------------------------------------------------
認証成功！
```

**図解: メッセージ交換の詳細**

もう少し詳細なメッセージの流れを図で見てみましょう。以下の図は、SCRAM-SHA-1 の例を基に簡略化したものです。

```
クライアント                                             サーバー
----------------------------------------------------------------------
1. クライアント Hello
   username: user                                     ----->
                                                       <-----  2. サーバー First Message
                                                                r: realm
                                                                nonce: server-nonce
                                                                salt: salt-value
                                                                i: iteration-count
3. クライアント Final Message
   c: channel-binding (optional)
   r: realm (コピー)
   p: ClientProof (クライアント証明)                          ----->
                                                       <-----  4. サーバー Final Message
                                                                v: ServerSignature (サーバー署名)
----------------------------------------------------------------------
クライアント、サーバー 相互認証完了
```

**図の説明:**

* **クライアント Hello**:  ユーザー名のみを送信し、認証開始をサーバーに伝えます。
* **サーバー First Message**: サーバーは、認証に必要な情報（ソルト値 `salt`、サーバーnonce `server-nonce`、イテレーション回数 `i` など）をクライアントに送ります。`realm` は認証領域を示す識別子です。
* **クライアント Final Message**: クライアントは、パスワード、サーバーから受け取った情報、クライアント自身が生成した nonce (クライアントnonce) を基に計算した `ClientProof` を送信します。`r` はサーバーから受け取った `realm` をコピーして返します。`c` はオプションのチャネルバインディングデータです。
* **サーバー Final Message**: サーバーは、同様に計算した `ServerSignature` をクライアントに送信し、認証結果を伝えます。クライアントは `ServerSignature` を検証することでサーバーを認証できます。

**SCRAM の利点**

* **パスワードの秘匿性**: パスワードそのものをネットワーク上で送信しないため、盗聴によるパスワード漏洩のリスクを大幅に低減できます。
* **ソルトとハッシュ**: ソルト値を用いることで、レインボーテーブル攻撃を防ぎます。また、ハッシュ関数とイテレーション回数を用いることで、ブルートフォース攻撃に対する耐性を高めます。
* **相互認証**: クライアントとサーバーが互いに認証を行うため、中間者攻撃 (Man-in-the-Middle attack) を防ぐことができます。
* **多様なハッシュ関数**: SCRAM は、様々なハッシュ関数（SHA-1, SHA-256 など）をサポートしており、セキュリティ要件に応じて選択できます。

**まとめ**

SCRAM は、現代的な認証システムにおいて非常に強力な認証メカニズムです。パスワード認証のセキュリティ上の弱点を克服し、より安全な認証を実現します。RFC 5802 に詳細な仕様が記述されていますので、さらに深く理解したい場合は、ぜひ RFC を参照してください。
